//
// Created by wulong on 8/4/18.
//


#include <random>
#include "dependentlibs/cudaproj/dpcuda.h"

#include "../psmvalidator/dependentlibs/msbasic/commonfun.h"
#include "../psmvalidator/dependentlibs/msbasic/CDebugMode.h"

#include "../librarymsms/ConcreteQueries.h"
#include "../librarymsms/pathManager.h"
#include "../librarymsms/CMzFileReader.h"
#include "../librarymsms/Util.h"
#include "../librarymsms/GraphKNN.h"
#include "../librarymsms/ProteomicsDataTypes.h"
#include "../librarymsms/XMLFileParser.h"
#include "dependentlibs/spectralIndex/CKMeans.h"
#include "dependentlibs/spectralIndex/ICIndexWrapper.h"
#include "LibSearchEngine.h"
#include "dependentlibs/spectralIndex/CMultiIndices.h"


using namespace std;

string getIdentificationFileName(const string &rawdata, int topn_candidates, const string &outputpath);

boost::program_options::variables_map getParam(int argc, char *argv[]) {

    namespace po = boost::program_options;
    po::options_description libraryRetrievalOption("Command line only"), configs_infile("Config file");
    libraryRetrievalOption.add_options()
            ("config", po::value<string>(),
             "the config file")
            ("help,h", po::bool_switch()->default_value(false), "print help information");

    configs_infile.add_options()
            ("libraryfile,l", po::value<string>()->default_value(""),
             "the spectral library in sptxt format")
            ("searchspacefilelist,S", po::value<string>()->default_value(""),
             "search space file list; it could include spectral libraries, theoretical spectra files (mgf) and any other form mzXMLs (unknown)")
            ("rawdata,d", po::value<string>()->default_value(""),
             "the raw data in mzML or mzXML format as query")
            ("overwrite", po::bool_switch()->default_value(false),
             "overwrite the search results!")
            ("extsearch", po::bool_switch()->default_value(false),
             "search neighbour's neighbour! (second iteration)")
            ("thirditeration", po::bool_switch()->default_value(false),
             "do third iteration after second iteration!")
            ("comparetop2", po::bool_switch()->default_value(false),
             "Compare top2 in validation when second hit is correct!")
            ("removeprecursor", po::bool_switch()->default_value(false),
             "remove precursor and its neutral loss peaks in range of [mz-17, mz+3];")
            ("useflankingbin", po::bool_switch()->default_value(false),
             "use flanking bin for building index;")
            ("psm", po::value<string>()->default_value(""),
             "validate the candidates generated with a PSM list generated by xinteract in ipro.pep.xml format")
            ("use_gpu,g", po::bool_switch()->default_value(false),
             "use gpu or not")
            ("annrecall", po::bool_switch()->default_value(false),
             "validate the recall of ANNs, approximate nearest neighbors")
            ("nprobe", po::value<int>()->default_value(256),
             "number of IVFs to search; default: 256 ")
            ("batchsize", po::value<int>()->default_value(1000),
             "the batch size for gpu query, default: 1000 ")
            ("precursormztol", po::value<double>()->default_value(0),
             "precursor mz tolerance; default: 0 Th")
            ("indexchoice", po::value<int>()->default_value(-1),
             "the choice of index; -1 (merge); 0, choose index 1 only; 1 choose index 2 only. ")
            ("spec_start", po::value<long>()->default_value(0),
             "the start spectrum index. default: 0 ")
            ("spec_end", po::value<long>()->default_value(-1),
             "the end of spectrum index; -1 means identify all spectra; values larger than spec_start means only identify spectra with index between spec_start and spec_end. default: -1 ")
            ("topn", po::value<int>()->default_value(50),
             "The number of true neighbours retained. Default: 50")
            ("annnumber", po::value<int>()->default_value(1024),
             "The number of ANNs (approximate nearest neighbor) retained in each index. Default: 1024")
            ("outputpath", po::value<string>()->default_value("output"),
             "the output folder name relative to the data file. Or using absolute path.  Therefore, both \"output\" and \"/path/to/my/output\" are OK")
            ("indexpath", po::value<string>()->default_value("indices"),
             "the folder name for index storage")
            ("indexstrings", po::value<string>()->default_value("IVF256,PQ16"),
             "the string for index_factory() to build index");


    libraryRetrievalOption.add(configs_infile);
    boost::program_options::variables_map vm;
    po::positional_options_description p;
    p.add("inputfile", -1);
    po::store(po::command_line_parser(argc, argv).options(libraryRetrievalOption).positional(p).run(), vm);
    if (vm.count("config")) {
        std::ifstream ifs{vm["config"].as<std::string>().c_str()};
        if (ifs)
            store(parse_config_file(ifs, configs_infile), vm);
    }
    po::notify(vm);
    if (vm.at("help").as<bool>()) {
        cout << libraryRetrievalOption << endl;
        cout << "Help info finish" << endl;
        displayParam(vm);
        exit(0);
    }
    return vm;
}


void getRealDotProduct(int i, int topN_Peaks, int tol, ICMzFile &mzFile,
                       vector<long> &int_ind, vector<double> &realscore) {
    uint16_t *queryspec = mzFile.getSpecBy(i);
    vector<int> scores;
    mzFile.calcDotProduct(topN_Peaks, tol, queryspec, 32, int_ind, scores);
    realscore.assign(scores.begin(), scores.end());

}

void getTopKCandidates(vector<long> &int_ind, vector<double> &realscore, int topn_candidates, vector<long> &candidates,
                       vector<double> &candidatesSim) {
    vector<int> sortIDX(int_ind.size(), 0);
    iota(sortIDX.begin(), sortIDX.end(), 0); // 0,1,2,3,...,1023
    sort(sortIDX.begin(), sortIDX.end(),
         [&realscore](const int &x, const int &y) -> bool { return realscore[x] > realscore[y]; });

    candidates.assign(topn_candidates, -1);
    candidatesSim.assign(topn_candidates, 0);
    for (int k = 0; k < topn_candidates and k < sortIDX.size(); k++) {
        candidates[k] = int_ind[sortIDX[k]];
        candidatesSim[k] = realscore[sortIDX[k]];
    }
}

///
/// Get query spectra, a vector of 4096 dimention, normalize it, get 1024 ANNs
/// Calculate the real similarity in GPU for query spectra and its 1024 ANNs
/// Refine the list of candidates from 1024 to 50
void getKnn(ICMzFile &mzFile, CMultiIndices &indices, int queryindex, int dim, int ret_num, int topN_Peaks, int tol,
            int topn_candidates, vector<double> &candidatesSim, vector<long> &candidates,
            bool useFlankingBins) {
    // get 1024 ANNs with id
    vector<long> int_ind;
    vector<vector<long>> results;
    vector<long> queries{queryindex};

    CMzQuery mzquery(mzFile, dim, queries, useFlankingBins);
    indices.getAnns(mzquery, ret_num, results);
    for (int i = 0; i < results.size(); i++) {
        int_ind.insert(int_ind.end(), results[i].begin(), results[i].end());
    }
    stableUniqueVector_deprecated(int_ind, false);

    vector<double> realscore;
    getRealDotProduct(queryindex, topN_Peaks, tol, mzFile, int_ind, realscore);

    getTopKCandidates(int_ind, realscore, topn_candidates, candidates, candidatesSim);

}


void buildKnnGraph(ICMzFile &mzFile, CMultiIndices &indices, int dim, int numCandidates,
                   string KNNGraphfile, bool useFlankingBins, int ret_num) {

    if (File::isExist(KNNGraphfile)) {
        cout << "File exist! Skip this step..." << endl;
        return;
    }
    int tol = 15;

    int topN_Peaks = 50;

    ofstream fout(KNNGraphfile, ios::binary | ios::out);
    long *tempKNNId = new long[numCandidates];
    Progress ps(mzFile.getSpecNum(), "Building KNN Graph");
    // todo: question: why KNN is using multiple thread??
    // We should do it in batch!
    for (int i = 0; i < mzFile.getSpecNum(); i++) // todo: do it one by one or in batch?
    {
        ps.increase();
        vector<double> candidatesSim;
        vector<long> candidatesId;
        getKnn(mzFile, indices, i, dim, ret_num, topN_Peaks, tol, numCandidates, candidatesSim, candidatesId,
               useFlankingBins);

        copy(candidatesId.begin(), candidatesId.end(), tempKNNId);
        fout.write((char *) tempKNNId, numCandidates * sizeof(long));

    }
    delete[] tempKNNId;
    fout.close();
    cout << "KNN graph created!" << endl;
}

//-- create table item ---
// -- rank; idx;  dot-product; peptide/charge; precursorMz; deltaMz
void add_topn_candidates_to_table(int topn_candidates, vector<long> &candidatesAllTopK,
                                  vector<double> &candidateSimAllTopK, double total_score_norm, vector<string> &temprow,
                                  double query_precursor_mz, DataFile &splib) {
    for (int k = 0; k < topn_candidates; k++) {
        if (candidatesAllTopK[k] == -1) {
            string tmpstr = to_string(k) + ";";
            tmpstr += to_string(-1) + ";";
            tmpstr += to_string(0) + ";";
            tmpstr += "UNKNOWN;";
            tmpstr += to_string(-1) + ";";
            tmpstr += to_string(-1);
            temprow.push_back(tmpstr);

        } else {
            string tmpstr = to_string(k) + ";";
            tmpstr += to_string(candidatesAllTopK[k]) + ";";
            tmpstr += to_string_with_precision(candidateSimAllTopK[k] / total_score_norm, 4) + ";";
            tmpstr += splib.getSpectrum(candidatesAllTopK[k])->getSpectrumName() + ";";
            double lib_item_mz = splib.getSpectrum(candidatesAllTopK[k])->m_parentMz;
            tmpstr += to_string_with_precision(lib_item_mz, 4) + ";";
            double delta_mz = query_precursor_mz - splib.getSpectrum(candidatesAllTopK[k])->m_parentMz;
            tmpstr += to_string_with_precision(delta_mz, 4);
            temprow.push_back(tmpstr);
        }
    }
}

/// Do extension search
void ExtendSearch(ICMzFile &mzFile, CMultiIndices &indices, int dim, int ret_num, vector<long> &allNNs,
                  vector<long> &candidates, DataFile &df, int topn_candidates, bool useFlankingBins,
                  bool doThirdIteration, GraphKNN &kNN) {
    if (!kNN.empty()) {
        spdlog::get("A")->info("Running extendSearch with no k-NN graph built in advance. It will take some time...");
        CMzQuery mzquery(mzFile, dim, candidates, useFlankingBins);
        vector<vector<long>> results;
        indices.getAnns(mzquery, ret_num, results);
        for (int i = 0; i < results.size(); i++) {
            allNNs.insert(allNNs.end(), results[i].begin(), results[i].end());

        }
    } else {
        for (int k = 0; k < kNN.ncandidates; k++) {
            long *p = kNN.getRow(candidates[k]);

            allNNs.insert(allNNs.end(), p, p + kNN.ncandidates);

            if (doThirdIteration) {
                int topN_third_round = 50;
                for (int j = 0; j < topN_third_round; j++) {

                    long *q = kNN.getRow(p[j]);
                    allNNs.insert(allNNs.end(), q, q + kNN.ncandidates);
                }

            }
        }
    }

}


void filter_with_precursor_tolerance(vector<long> &allNNs,
                                     double precursor_mz_tolerance, double query_precursor_mz, DataFile &splib) {
    vector<long> tmpNNs;
    for (int l = 0; l < allNNs.size(); l++) {
        double lib_precursor = splib.getSpectrum(allNNs[l])->m_parentMz;
        if (fabs(lib_precursor - query_precursor_mz) < precursor_mz_tolerance) {
            tmpNNs.push_back(allNNs[l]);
        }
    }
    allNNs.swap(tmpNNs);
}


void identification(ICMzFile &mzFile, string rawdata, CMzFileReader &csa_rawdata, int dim, DataFile &df,
                    DataFile &splib, bool use_gpu, int topn_candidates, string knngraphfile, bool doExtendSearch,
                    long spec_start, long spec_end, bool useFlankingBins, double precursor_mz_tolerance, int batchsize,
                    bool thirdIteration, int numANNs, CMultiIndices &indices, int indexChoice, string searchResult) {
    int numAnn = numANNs;
    spdlog::get("A")->info("Identification: getting top {} from {} ANNs", topn_candidates, numAnn);
    bool doThirdIteration = thirdIteration;

    int tol = 15;
    int topN_Peaks = 50;

    CTable topCandidatesTable;

    spdlog::get("A")->info("start identification");

    if (use_gpu) indices.toGpu();

    GraphKNN kNN(topn_candidates);
    if (File::isExist(knngraphfile)) {
        kNN.load_knn_graph_from_file(knngraphfile);
    }

    SimpleTimer st("identification");

    if (spec_start < spec_end and spec_end <= csa_rawdata.getSpecNum() and spec_start >= 0) {
        cout << "[Info] Using user defined spec range [" << spec_start << ", " << spec_end << "]" << endl;
    } else {
        spec_start = 0;
        spec_end = csa_rawdata.getSpecNum();
        cout << "[Info] Using default spec range [" << spec_start << ", " << spec_end << "]" << endl;
    }
    double total_score_norm = 0;
    for (int i = 1; i <= 50; i++) { total_score_norm += i * i; } // 42925
    cout << "[Info] Total score is: " << total_score_norm << endl;

    Progress ps(spec_end - spec_start, "identification");
    int num_spec_with_zero_candidates = 0;

    long i = spec_start;

    while (i < spec_end) {
        vector<long> candidates;
        vector<vector<long>> results;

        int numQuery = batchsize > spec_end - i ? spec_end - i : batchsize;
        vector<long> queries(numQuery, 0);
        iota(queries.begin(), queries.end(), i);
        i += numQuery;

        CMzQuery mzquery(csa_rawdata, dim, queries, useFlankingBins);
        indices.getAnns(mzquery, numAnn, results);


        for (int k = 0; k < numQuery; k++) {
            ps.increase();

            vector<long> allNNs;
            indices.collectANNs(indexChoice, numAnn, results, k, allNNs, false);

            if (doExtendSearch and !kNN.empty()) {
                ExtendSearch(mzFile, indices, dim, numAnn, allNNs, candidates, df,
                             topn_candidates, useFlankingBins, doThirdIteration, kNN);
            }
            // unique outside!!!
            stableUniqueVector_deprecated(allNNs, false);

            int idx = queries[k];
            double query_precursor_mz = df.getSpectrum(df.getIdx(idx))->m_parentMz;

            if (precursor_mz_tolerance > EPSILON) {
                // todo: we should filter it earlier
                filter_with_precursor_tolerance(allNNs, precursor_mz_tolerance, query_precursor_mz, splib);
            }

            if (allNNs.size() == 0) {
                num_spec_with_zero_candidates++;
                continue;
            }

            vector<double> allrealscore;

            vector<int> scores;
            mzFile.calcDotProduct(topN_Peaks, tol, csa_rawdata.getSpecBy(idx), 32, allNNs, scores);

            allrealscore.assign(scores.begin(), scores.end());

            vector<long> candidatesAllTopK;
            vector<double> candidateSimAllTopK;
            getTopKCandidates(allNNs, allrealscore, topn_candidates, candidatesAllTopK, candidateSimAllTopK);

            // store to file
            vector<string> temprow;
            temprow.push_back(to_string(df.getSpectrum(df.getIdx(idx))->m_scanNum));
            temprow.push_back(df.getSpectrum(df.getIdx(idx))->m_spectrum_name);

            add_topn_candidates_to_table(topn_candidates, candidatesAllTopK, candidateSimAllTopK, total_score_norm,
                                         temprow, query_precursor_mz, splib);

            topCandidatesTable.addRow(temprow);
        }
    }
    topCandidatesTable.saveAs(searchResult, false, '\t');
    st.stop();
    indices.toCpu();
    spdlog::get("A")->info("Identification finishes!\n");
    spdlog::get("A")->info("{} spectra found 0 candidates and not identified!", num_spec_with_zero_candidates);
    spdlog::get("A")->info("Top {} candidates are saved in  {}", topn_candidates, searchResult);
}

string getIdentificationFileName(const string &rawdata, int topn_candidates, const string &outputpath) {
    string rawdatapath, rawdataname;
    File::parent(rawdata, rawdatapath, rawdataname);
    string searchResult = outputpath + "/" + rawdataname + ".top" + to_string(topn_candidates) + ".tsv";
    return searchResult;
}

string getIdentificationRecallFileName(const string &rawdata, int topn_candidates, const string &outputpath) {
    string rawdatapath, rawdataname;
    File::parent(rawdata, rawdatapath, rawdataname);
    string recallFileName = outputpath + "/" + rawdataname + ".top" + to_string(topn_candidates) + ".recall";
    return recallFileName;
}

/// Start validation based on interact-.pep.xml files: using those PSMs above threshold (fdr<0.01)
/// \param topNTsvFile
/// \param ipropepxmlfilename
/// \param topn_candidates
/// \param compare_rank2_rank1
void validation(string topNTsvFile, string ipropepxmlfilename, int topn_candidates, bool compare_rank2_rank1,
                string recallfilename) {
    spdlog::get("A")->info("Validating recall@top{} neighbours", topn_candidates);
    string pepxmlfile = ipropepxmlfilename;

    PeptideProphetParser ppp(pepxmlfile);
    double thresholdOfFdr = ppp.getThresholdForFDR(0.01, false);
    cout << "[Info] PeptideProphet probability score with FDR < 0.01 is " << setprecision(4) << thresholdOfFdr << endl;

    CTable topNTsvTable(topNTsvFile, '\t', false, 0);

    const int scan_col = 0;

    ofstream fout(recallfilename.c_str(), ios::out);
    int psmCount = 0;
    map<int, int> psmCountsInKthBucket;
    for (int i = 0; i < topNTsvTable.m_row; i++) {
        int scan = atoi(topNTsvTable.getEntry(i, scan_col).c_str());
        PSMInfo psminfo;
        bool found_psm = ppp.getPSMInfobyScan(scan, psminfo);
        if (not found_psm
            or psminfo.searchhits[0]->m_peptideprophet_prob < thresholdOfFdr)
            continue;
        else {
            psmCount++;
        }
        string peptide = psminfo.searchhits[0]->m_modified_peptide;

        int recall_topn = 1001;
        if (psminfo.isDecoy(true, 0)) {
            recall_topn = 1002;
        }
        for (int k = 2; k < topNTsvTable.m_col; k++) {
            string current_id = topNTsvTable.getEntry(i, k);
            vector<string> tokens;
            split_string(current_id, tokens, ';');
            current_id = tokens[3];
            current_id = current_id.substr(0, current_id.find_last_of('/'));
            if (current_id == peptide) {
                recall_topn = k - 1;
                break;
            }
        }
        if (recall_topn == 2 and compare_rank2_rank1) // rank 2
        {
            // todo: why we have this?
            enum tsvColumns {
                spectrumid, spectrumname, rank1result, rank2result
            };

            cout << "Rank2\t" << topNTsvTable.getEntry(i, spectrumid)
                 << "\t" << topNTsvTable.getEntry(i, spectrumname)
                 << "\t" << topNTsvTable.getEntry(i, rank1result)
                 << "\t" << topNTsvTable.getEntry(i, rank2result)
                 << endl;
        } else if (recall_topn == 1001) {

        }

        fout << scan << "\t" << peptide << "\t" << recall_topn << endl;
        if (psmCountsInKthBucket.find(recall_topn) == psmCountsInKthBucket.end()) {
            // Not found key
            psmCountsInKthBucket[recall_topn] = 1;
        } else {
            // found key
            psmCountsInKthBucket[recall_topn]++;
        }
    }
    fout.close();

    // Print the counts of psm in each bucket
    cout << "Total number of PSM above threshold: " << psmCount << endl;
    cout << "// Start recall (Type-K = 1001 means the true peptide not found in top K)" << endl
         << "Type-K\tCounts@K\tRecall@K\tACCRecall@k" << endl;
    int accumulatedCounts = 0;
    for (map<int, int>::iterator it = psmCountsInKthBucket.begin();
         it != psmCountsInKthBucket.end();
         it++) {
        accumulatedCounts += it->second;
        cout << it->first << "\t" << it->second << "\t" << setprecision(4) << 1.0 * it->second / psmCount << "\t"
             << 1.0 * accumulatedCounts / psmCount << "\t";
        if (it->first == 1001) {
            cout << "Correct libraries spectra NOT fount in top " << topn_candidates;
        } else if (it->first == 1002) {
            cout << "Matched to decoy protein";
        }
        cout << endl;
    }
    cout << "// End of Recall" << endl;
    spdlog::get("A")->info("Recall@Top{} info is saved in  {}", topn_candidates, recallfilename);
}

void displayTitle() {
    spdlog::get("A")->info("\n"
                           "-------------------------------------------------\n"
                           "#     Open Spectral Library Search with GPU     #\n"
                           "#       Build Date: {} {}        #\n"
                           "#     Developed in Henry Lam's Group @ HKUST    #\n"
                           "-------------------------------------------------", __DATE__, __TIME__);
}

// Open search against Spectral Libraries
// idea:
// 1) embedding spectra into a low dimensional space
// 2) search for k-ANN (approximate nearest neighbours) in the embedding space
// 3) rerank k-ANN to get refined K-NN spectra
// 4) get truth from the K nearest neighbours
//    get feature from the K nearest neighbours.
// By: Long WU
// Updated: 2019 Jan. 2


/// The problem we are facing here
/// The extension search (second round search) does not help on recall
/// 94.51% -> 94.53%
/// So we will stop work in that way! We are going to make it better by using multiple index.
/// Multiple Index:
/// So what is multiple index
/// \param argc
/// \param argv
/// \return
int main(int argc, char *argv[]) {
    try {
        initlog("library_retrieval.log", "A");
        displayTitle();
        spdlog::get("A")->info("CMD: {}", argToStr(argc, argv));

        // Read Parameters  ----------
        auto vm = getParam(argc, argv);
        string rawdata = vm["rawdata"].as<string>();
        string libraryfile = vm["libraryfile"].as<string>();
        string indexstring = vm["indexstrings"].as<string>();

        string KNNGraphfile = libraryfile + ".knn";
        string ipropepxmlfilename = vm["psm"].as<string>();
        int numCandidates = vm["topn"].as<int>();
        int nprobe = vm["nprobe"].as<int>();
        bool overwrite = vm["overwrite"].as<bool>();
        bool extsearch = vm["extsearch"].as<bool>();
        bool use_gpu = vm["use_gpu"].as<bool>();
        long spec_start = vm["spec_start"].as<long>();
        long spec_end = vm["spec_end"].as<long>();
        bool removeprecursor = vm["removeprecursor"].as<bool>();
        bool useflankingbin = vm["useflankingbin"].as<bool>();
        bool comparetop2 = vm["comparetop2"].as<bool>();
        double precursor_mz_tolerance = vm["precursormztol"].as<double>();
        int batch_size = vm["batchsize"].as<int>();
        int ret_num = vm["annnumber"].as<int>();
        bool thirdIteration = vm["thirditeration"].as<bool>();
        bool validateAnns = vm["annrecall"].as<bool>();
        int indexchoice = vm["indexchoice"].as<int>();

        string outputpath = vm["outputpath"].as<string>(); // this is not path, this is name todo
        string indexpath = vm["indexpath"].as<string>();  // this is not path, this is name todo

        string datapath, filename;
        File::parent(rawdata, datapath, filename);
        outputpath = datapath + "/" + outputpath;
        createDirectory(outputpath);

        if (batch_size < 1 or batch_size > 10000) {
            batch_size = 1000;
        }

        displayParam(vm);

        // Read Parameters Done --
        if (indexstring.empty() or rawdata.empty() or libraryfile.empty()) {
            cout
                    << "Please specify the following parameters: '--rawdata', '--libraryfile' and '--indexstring' through commandline."
                    << endl;
            return 0;
        }

        // Section I: Spectral Library
        spdlog::get("A")->info("loading library {}", libraryfile);
        DataFile dflib(libraryfile,0,-1);

        // Searchable spectra in CPU

        int tol = 1;
        double tol_index = 2 * tol * 2000.0 / 65535;

        CMzFileReader compactLibrary(dflib, overwrite, removeprecursor, nullptr, tol_index, 6, false);
        // Search spectra in GPU: based on mz file
        //shared_ptr<ICMzFile> pIMzFile = nullptr;

        ICMzFile *mzFile = &compactLibrary;

#ifndef __CUDA__
        if(use_gpu)
            {
            cout << "GPU not available, will use CPU" << endl;
            use_gpu = false;
            }
#endif
        if (use_gpu) {
#ifdef __CUDA__
            mzFile = new CUDAScore(libraryfile + ".mz");  // it is easy to controll from here //OK
#endif
        }

        // Create faiss index for Search Spectra
        int dim = 4096;
        long specnum = 0;

        string libpath, libname;
        File::parent(libraryfile, libpath, libname);
        indexpath = libpath + "/" + indexpath;
        createDirectory(indexpath);

        bool useMyOwn = true;
        int topPeakNum = 50;
        CPQParam cpqparam;
        CMultiIndices indices(indexstring, indexpath, libname, true, tol_index, useMyOwn,
                              make_shared<CPQParam>(cpqparam), topPeakNum, removeprecursor, useflankingbin, dim);
        // todo: to be removed! Todo:
        indices.create(specnum, dflib, removeprecursor, useflankingbin);
        indices.setNprobe(nprobe, false);
        indices.display();

        // Build KNN for all the spectra in Search Space
        if (extsearch) {
            spdlog::get("A")->info("Creating KNN graph for extension search...");
            buildKnnGraph(*mzFile, indices, dim, numCandidates, KNNGraphfile, useflankingbin,
                          ret_num);
        }

        // Section II: Experimental Spectra
        spdlog::get("A")->info("Loading query data file...");
        DataFile df(rawdata,0,-1);
        // Put Query into Memory
        spdlog::get("A")->info("Converting query data as mz file");

        bool isfilelist = false;

        CMzFileReader compactRawData(df, overwrite, removeprecursor, nullptr, tol_index, 6, false);
        // Subsection II.I do verification on candidates
        if (validateAnns) {
            indices.recallOfAnn(df, ipropepxmlfilename, compactRawData, useflankingbin, dim, dflib,
                                use_gpu, indexchoice, batch_size, outputpath, ret_num, spec_start, spec_end);
        }
        // Section III: identification
        string topNTsvFile = getIdentificationFileName(rawdata, numCandidates, outputpath);
        if (not File::isExist(topNTsvFile) or overwrite) {
            identification(*mzFile, rawdata, compactRawData, dim, df, dflib, use_gpu,
                           numCandidates, KNNGraphfile, extsearch, spec_start, spec_end, useflankingbin,
                           precursor_mz_tolerance,
                           batch_size, thirdIteration, ret_num, indices, indexchoice, topNTsvFile);
        } else {
            spdlog::get("A")->info("File exists: {}", topNTsvFile);
        }

        // Section IV: Validation with search result
        string recallfilename = getIdentificationRecallFileName(rawdata, numCandidates, outputpath);
        if (not File::isExist(recallfilename) or overwrite) {
            validation(topNTsvFile, ipropepxmlfilename, numCandidates, comparetop2, recallfilename);
        } else {
            spdlog::get("A")->info("File exists: {}", recallfilename);
        }

        spdlog::get("A")->info("Releasing resources");

        //if (gpuscore) delete gpuscore;
        spdlog::get("A")->info("Program finishes!");
    }
    catch (exception &e) {
        cout << "Get error: " << e.what() << endl;
    }
    catch (...) {
        cout << "Get Unknown error" << endl;
    }
    return 0;
}
